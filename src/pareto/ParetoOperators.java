/*
 * ParetoOperators.java
 * created 19 September 2012
 */

package pareto;

/**
 * @author Christopher Simons
 */

import config.AlgorithmParameters;
import engine.*;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import myUtils.Weights;


public class ParetoOperators 
{
    /**
     * Select the path with the least domination count
     * note this uses a flexible definition of non-domination.
     * not used at 24 Sept 2012
     * @param the solution paths generated by the colony of ants 
     * @return the selected path 
     */
    public static Path selectPathWithLeastDominationCount( List< Path > colony )
    {
        assert colony != null;
        
        final int size = colony.size( );
        int[ ] domCounts = new int[ size ];  
        
        for( int i = 0; i < size; i++ )
        {
            domCounts[ i ] = 0;
        }
        
        for( int i = 0; i < size; i ++ )
        {
            Path p = colony.get( i );
            
            final double CBO = p.getCBO( );
            final double NAC = p.getEleganceNAC( );
            final double ATMR = p.getEleganceATMR( );
            
            for( int j = 0; j < size; j++ )
            {
                if( i != j && CBO > colony.get( j ).getCBO( ) ) 
                {
                    domCounts[ i ]++;
                }
                if( i != j && NAC > colony.get( j ).getEleganceNAC( ) ) 
                {
                    domCounts[ i ]++;
                }
                if( i != j && ATMR > colony.get( j ).getEleganceATMR( ) ) 
                {
                    domCounts[ i ]++;
                }
            }
        } 
        
        int minCount = 1000, index = 0;
        for( int i = 0; i < size; i ++ )
        {
            if( domCounts[ i ] < minCount )
            {
                minCount = domCounts[ i ];
                index = i;
            }
        }
        
//        System.out.println( "min domination count is: " + minCount );
//        System.out.println( "selected index is: " + index );

        return colony.get( index );
    }
       
    
    /**
     * Select the path with the least domination count
     * NB this method uses the "weighted" domination count.
     * @param the solution paths generated by the colony of ants 
     * @return the selected path 
     */
    public static Path selectPathWithLeastWeightedDominationCount( 
        List< Path > colony, Weights weights )
    {
        assert colony != null;
        assert weights != null;
        
        final int size = colony.size( );
        int[ ] domCountsCBO = new int[ size ];  
        int[ ] domCountsNAC = new int[ size ];  
        int[ ] domCountsATMR = new int[ size ]; 
        int[ ] domCountsTotal = new int[ size ];
        
        for( int i = 0; i < size; i++ ) 
        {
            domCountsCBO[ i ] = 0;
            domCountsNAC[ i ] = 0;
            domCountsATMR[ i ] = 0;
            domCountsTotal[ i ] = 0;
        }
        
        
        for( int i = 0; i < size; i ++ )
        {
            Path p = colony.get( i );
            
            final double CBO = p.getCBO( );
            final double NAC = p.getEleganceNAC( );
            final double ATMR = p.getEleganceATMR( );
            
            for( int j = 0; j < size; j++ )
            {
                if( i != j && CBO > colony.get( j ).getCBO( ) ) 
                {
                    domCountsCBO[ i ]++;
                }
                if( i != j && NAC > colony.get( j ).getEleganceNAC( ) ) 
                {
                    domCountsNAC[ i ]++;
                }
                if( i != j && ATMR > colony.get( j ).getEleganceATMR( ) ) 
                {
                    domCountsATMR[ i ]++;
                }
            }
        } 
        
        // multiply the weights by 100
        double weightPercentageCBO = weights.weightCBO * 100;
        assert weightPercentageCBO <= 100.0 && weightPercentageCBO >= 0.0;
        double weightPercentageNAC = weights.weightNAC * 100;
        assert weightPercentageNAC <= 100.0 && weightPercentageNAC >= 0.0;
        double weightPercentageATMR = weights.weightATMR * 100;
        assert weightPercentageATMR <= 100.0 && weightPercentageATMR >= 0.0;
          
        // multiply the domination counts for each objective
        // by the ( weight * 100 )
        for( int i = 0; i < size; i ++ )
        {
             domCountsCBO[ i ] *= weightPercentageCBO;
             domCountsNAC[ i ] *= weightPercentageNAC;
             domCountsATMR[ i ] *= weightPercentageATMR;
        }
        
        // sum the domination counts for each solution path
        for( int i = 0; i < size; i ++ )
        {
            domCountsTotal[ i ] = 
                domCountsCBO[ i ] +
                domCountsNAC[ i ] +
                domCountsATMR[ i ];
        }
        
        // find the least dominated solutions path
        // for the weighted domination counts
        int minCount = AlgorithmParameters.NUMBER_OF_ANTS * size; 
        int index = 0;
        
        for( int i = 0; i < size; i ++ )
        {
            if( domCountsTotal[ i ] < minCount )
            {
                minCount = domCountsTotal[ i ];
                index = i;
            }
        }
        
//        System.out.println( "min domination count is: " + minCount );
//        System.out.println( "selected index is: " + index );

        return colony.get( index );
    }
    
    /**
     * this method calculates the "special" domination count
     * i.e. number of solutions better than this one
     * with respect to INDIVIDUAL objective fitness functions
     * @param colony 
     */
    public static void calculateSpecialDominationCount( List< Path > colony )
    {
        assert colony != null;
        
        final int size = colony.size( );
        int domCount = 0;  
        
        for( int i = 0; i < size; i ++ )
        {
            Path p = colony.get( i );
            
            final double CBO = p.getCBO( );
            final double NAC = p.getEleganceNAC( );
            final double ATMR = p.getEleganceATMR( );
            
            for( int j = 0; j < size; j++ )
            {
                if( i != j && CBO > colony.get( j ).getCBO( ) ) 
                {
                    domCount++;
                }
                if( i != j && NAC > colony.get( j ).getEleganceNAC( ) ) 
                {
                    domCount++;
                }
                if( i != j && ATMR > colony.get( j ).getEleganceATMR( ) ) 
                {
                    domCount++;
                }
            }
            
            p.setDominationCount( domCount );
        } 
        
    }
    
    /**
     * calculate the domination count for each ant 
     * (design solution) in the colony
     * @param colony 
     */
    public static void calculateDominationCount2( List< Path > colony )
    {
        assert colony != null;
        
        final int size = colony.size( );
        Iterator< Path > outer = colony.iterator( );
        
        while( outer.hasNext( ) )
        {
            Path outerLoopPath = outer.next( );
//            System.out.println( "domination count before is: " + outerLoopPath.getDominationCount( ) );
            
            
            assert outerLoopPath.getDominationCount( ) == 0 :
                "domination count is: " + outerLoopPath.getDominationCount( ) ;
            
            final double outerCBO = outerLoopPath.getCBO( );
            final double outerNAC = outerLoopPath.getEleganceNAC( );
            
            Iterator< Path > inner = colony.iterator( );
            
            while( inner.hasNext( ) )
            {
                Path innerLoopPath = inner.next( );
                
                performDominationTournament( 
                    outerLoopPath, outerCBO, outerNAC, innerLoopPath );
            }
//            System.out.println( "domination count after is: " + outerLoopPath.getDominationCount( ) );
            assert outerLoopPath.getDominationCount( ) < size :
                "domination count is: " + outerLoopPath.getDominationCount( ) ;
        }
    }
    
    /**
     * perform pareto-based domination tournament
     * @param outer loop solution path
     * @param inner loop solution path
     */
    private static void performDominationTournament( 
        Path outer, double outerCBO, double outerNAC, Path inner )
    {
//        final double outerCBO = outer.getCBO( );
//        final double outerNAC = outer.getEleganceNAC( );
//        final double outerATMR = outer.getEleganceATMR( );
        
        final double innerCBO = inner.getCBO( );
        final double innerNAC = inner.getEleganceNAC( );
//        final double innerATMR = inner.getEleganceATMR( );

        boolean outerCBOWorse = false;
        boolean outerCBOEqual = false;
        boolean outerNACWorse = false;
        boolean outerNACEqual = false;
//        boolean outerATMRBetter = false;
//        boolean outerATMREqual = false;
//        
        if( outerCBO > innerCBO ) { outerCBOWorse= true; }
        if( outerCBO == innerCBO ) { outerCBOEqual = true; }
        if( outerNAC > innerNAC ) { outerNACWorse= true; }
        if( outerNAC == innerNAC ) { outerNACEqual = true; }
//        if( outerATMR < innerATMR ) { outerATMRBetter = true; }
//        if( outerATMR == innerATMR ) { outerATMREqual = true; }
        
        if( outerCBOWorse && outerNACWorse /* && outerATMRBetter */ )
        {
            outer.incrementDominationCount( );
        }
//        else if ( outerCBOBetter && outerNACBetter /* && outerATMREqual */ )
//        {
//            inner.incrementDominationCount( );
//        }
        else if ( outerCBOWorse && outerNACEqual /* && outerATMREqual */ )
        {
            outer.incrementDominationCount( );
        }
//        else if( outerCBOEqual && outerNACBetter /* && outerATMRBetter */ )
//        {
//            inner.incrementDominationCount( );
//        }
        else if ( outerCBOEqual && outerNACWorse  /* && outerATMREqual */ )
        {
            outer.incrementDominationCount( );
        }
//        else if ( outerCBOEqual && outerNACEqual /* && outerATMREqual */ )
//        {
//            inner.incrementDominationCount( );
//        }
        
    }
    
    /**
     * get the true non-dominated solutions in the colony.
     * precondition: calculateDominationCount2 must have beeb previously called 
     * @param colony
     * @return list of paths containing non-dominated solution(s)
     */
    public static List< Path > getNomDoms( List< Path > colony )
    {
        List< Path > nonDoms = new ArrayList< Path >( );
        
        Iterator< Path > it = colony.iterator( );
        
        while( it.hasNext( ) )
        {
            Path p = it.next( );
            
            if( p.getDominationCount( ) == 0 )
            {
                nonDoms.add( p );
            }
        }
        
        return nonDoms;
    }
    
    
    /** calculate the 'special' domination count and
     * multiply it by the weights
     * @param colony
     * @param weights 
     */
    public static void calculateWeightedDominationCount( List< Path > colony, Weights weights )
    {
        assert colony != null;
        assert weights != null;
        
        final int size = colony.size( );
        int domCountCBO = 0;  
        int domCountNAC = 0;  
        int domCountATMR = 0;  
        
        // multiply the weights by 100
        double weightPercentageCBO = weights.weightCBO * 100;
        assert weightPercentageCBO <= 100.0 && weightPercentageCBO >= 0.0;
        double weightPercentageNAC = weights.weightNAC * 100;
        assert weightPercentageNAC <= 100.0 && weightPercentageNAC >= 0.0;
        double weightPercentageATMR = weights.weightATMR * 100;
        assert weightPercentageATMR <= 100.0 && weightPercentageATMR >= 0.0;
        
        for( int i = 0; i < size; i ++ )
        {
            Path p = colony.get( i );
            
            final double CBO = p.getCBO( );
            final double NAC = p.getEleganceNAC( );
            final double ATMR = p.getEleganceATMR( );
            
            for( int j = 0; j < size; j++ )
            {
                if( i != j && CBO > colony.get( j ).getCBO( ) ) 
                {
                    domCountCBO++;
                }
                if( i != j && NAC > colony.get( j ).getEleganceNAC( ) ) 
                {
                    domCountNAC++;
                }
                if( i != j && ATMR > colony.get( j ).getEleganceATMR( ) ) 
                {
                    domCountATMR++;
                }
            }
        
            // multiply the domination counts for each objective
            // by the ( weight * 100 )
             domCountCBO *= weightPercentageCBO;
             domCountNAC *= weightPercentageNAC;
             domCountATMR *= weightPercentageATMR;
        
            // sum the domination counts for each solution path
            int weightedDomCountTotal = 
                domCountCBO +
                domCountNAC +
                domCountATMR;
        
            p.setDominationCount( weightedDomCountTotal );
        }
    }
    
    /**
     * 10 April 2013
     * @param colony
     * @param domCount
     * @return list of paths from the colony with required dom count 
     */
    public static List< Path > getPathsWithDomCount( List< Path > colony, int domCount )
    {
        assert colony != null;
        assert domCount >= 0;
        
        List< Path > result = new ArrayList< >( );
        
        for( Path p : colony )
        {
            if( p.getDominationCount( ) == domCount )
            {
                result.add( p );
            }
        }
        
        return result;
    }
    
}   // end class

//--------- end file ---------------------------------------------


